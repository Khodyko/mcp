Components view
1. Controller
Class: SupportAssistantController
Purpose: Exposes `/ask` endpoint, принимает пользовательские запросы в виде текста, валидирует вход, вызывает `OrchestratorService` и возвращает агрегированный ответ. Отвечает за слой HTTP, мэппинг DTO и преобразование ошибок в HTTP-ответы.

Responsibilities:
 - Принимать и валидировать входные запросы (DTO).
 - Логировать входящие запросы и ответы для дальнейшего анализа.
 - Делегировать обработку запросов в `OrchestratorService`.
 - Формировать единый HTTP-ответ, включая статус и возможные метаданные (latency, usedAgents).

2. Orchestration MCP
Class: OrchestratorService
Purpose: Анализирует входный текст, определяет набор агентов, которые должны обработать запрос, координирует их выполнение и агрегирует ответы в единый, консистентный результат.

Responsibilities:
 - Выполнять классификацию/рулинг запроса (простая эвристика или вызов LLM для intent-detection).
 - Выбирать агентов через `SupportAgent.canHandle(...)` (одного или несколько).
 - Асинхронно (или синхронно, в зависимости от конфигурации) вызывать `handle(...)` у выбранных агентов и собирать ответы.
 - Агрегировать ответы агентов (приоритеты, объединение фактов, дедупликация) и возвращать итоговую строку/структуру.
 - Предоставлять метаданные о задействованных агентах для логов и демонстрации.

3. Agents
Interface: SupportAgent

Интерфейс агента отвечает за контракт, по которому оркестратор взаимодействует с отдельными обработчиками.

Method: boolean canHandle(String query)
 - Определяет, может ли агент обработать данный запрос. Должен быть быстрым и детерминированным.

Method: String handle(String query)
 - Выполняет обработку запроса и возвращает ответ в текстовом виде или сериализуемой структуре.

Implementations:

Implementations:
OrderAgent – обрабатывает запросы, связанные с заказами; использует `OrderRepository` (PostgreSQL) и, при необходимости, `AiModelClient` для формулировки ответов;
ProductAgent – выполняет семантический поиск по каталогу продуктов через `Pgvector` (использует `EmbeddingService` и `VectorRepository`) и возвращает наиболее релевантные товары;
RecommendationAgent – формирует рекомендации на основе истории пользователя (`UserRepository`), метрик и, при необходимости, вызовов LLM;
FallbackAgent – возвращает стандартный ответ или проактивно предлагает действия (например, перенаправление в поддержку), если другие агенты не подошли.

Каждый агент:
 - Должен быть отдельным Spring-компонентом с четким контрактом.
 - Может использовать репозитории и клиенты (LLM, Embedding) внутри себя.
 - Должен логировать причины, по которым он отказался от обработки (canHandle=false) для отладки правил маршрутизации.

4. Embedding
Class: EmbeddingService
Purpose: Генерирует эмбеддинги (предпочтительно BGE-small), нормализует и кэширует их, обеспечивает API для сохранения и поиска эмбеддингов во `VectorRepository` (Pgvector).

Responsibilities:
 - Вызывать модель эмбеддингов для входных текстов.
 - Хранить эмбеддинги во `VectorRepository` с метаданными (productId, snippet).
 - Выполнять поиск ближайших соседей (k-NN) и возвращать релевантные записи для RAG.

5. AI Model integration client
Class: AiModelClient
Purpose: Унифицированный клиент для взаимодействия с LLM через Spring AI. Поддерживает вызовы локальной LLM (Ollama) и удалённой LLM, переключение стратегий, обработку таймаутов и ретраев.

Responsibilities:
 - Инкапсулировать детали конфигурации Spring AI и провайдеров моделей.
 - Выполнять запросы к LLM и возвращать структурированный ответ (text, tokens, usage).
 - Поддерживать fallback-логику между локальной и удалённой LLM.

6. Data access layer
Repositories:
OrderRepository – обеспечивает CRUD-операции для сущности `Order`, предоставляет методы выборки по `customerId`, `productId`, по статусу выполнения;
UserRepository – хранит профиль и историю действий/покупок пользователя, предоставляет данные для `RecommendationAgent`;
ProductRepository – CRUD и поиск базовых полей товара (name, type), используется `ProductAgent` и административными операциями;
VectorRepository – API доступа к Pgvector: сохранение эмбеддингов, поиск ближайших соседей, удаление/обновление записей.


Модель предметной области и связи
1) Product
 - `id` — PK
 - `name`, `description`, `price`, `stock`, `type`
 - Отношения: может иметь множество записей в `Order` (one-to-many)

2) Customer
 - `id` — PK
 - `name`
 - Отношения: имеет множество `Order` (one-to-many)

3) Order
 - `id` — PK
 - `productId` — FK -> `Product.id`
 - `customerId` — FK -> `Customer.id`
 - `quantity`, `fulfilled`
 - Отношения: принадлежит `Product` и `Customer`

Примечания по реализации связей:
 - В Entity моделях использовать ленивые загрузки для коллекций (FetchType.LAZY).
 - В DTO отдавать только необходимые поля (flat DTO), избегая циклических ссылок.
 - Для демонстрации связей достаточно простых репозиториев Spring Data JPA с аннотациями `@Entity` и связями `@ManyToOne` / `@OneToMany`.

Дополнительные классы и утилиты
- `ResponseAggregator` — утилита для объединения ответов агентов: ранжирование, объединение и формирование финального текста.
- `DemoDataLoader` — компонент запускаемый при старте профиля `demo`, наполняет БД товарами, заказами и пользователями, а также индексирует эмбеддинги.
